---
title: "0621-1 构造函数运行的机制和细节知识"
date: 2020-06-16
categories:
  - 前端
tags:
  - 珠峰高级
  - 学习笔记
sidebar: auto
keys:
  - "de9b9ed78d7e2e1dceeffee780e2f919"
---

```js
function Func(name, age) {
	var n = 10;
	this.name = name;
	this.age = age;
} 
```

**构造函数执行 new Xxx()**
构造函数执行就是创建自定义类和类所对应的实例的  
  Func被称为类  f1被称为当前类的一个实例
  1. 像普通函数执行一样，把函数执行，并且私有上下文和形参赋值等都操作一遍  
  2. 特殊的操作  
       - 在形成私有上下文之后，首先默认会创建一个对象（实例对象）
       - 让当前上下文中的THIS指向创建的这个对象
       - 所以接下来代码执行过程中所有的 this.xxx=xxx 都是给实例对象设置私有的属性和方法
       - 代码执行完成后，看是否有返回值，
          + 没有返回值默认返回创建的实例对象，
          + 如果有返回值，看返回值的类型，如果返回的是基本类型值，那么最后返回的还是实例对象，如果返回的是引用类型值，以自己返回的值为主  
  
因为构造函数执行既有普通函数执行的一面，也有自己特殊的一面，所以在所属私有上下文中，只有this.xxx=xxx才和实例对象有直接关系，而上下文中的私有变量等和实例对象没有必然的联系  

构造函数执行，在new的时候，类后面的小括号是没必要非要加的，不加也会当做构造函数执行，加或者不加的区别：  
不加小括号就没办法传递实参  
运算优先级的问题  new Func()【19】  new Fun【18】  
[运算优先级](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Operator_Precedence)

![](http://picbed.04091020.xyz/20200626114007.png)


```js
function Func() {
	this.name = 'xxx';
	this.age = 20;
	this.say = function say() {
		console.log(`my name is ${this.name}，i'm ${this.age} years old！`);
	};
}
var f1 = new Func;
var f2 = new Func;
// console.log(f1 === f2); //false
// console.log(f1.say === f2.say); //false
// console.log(f1.name === f2.name); //true

// 检测当前实例是否率属于这个类
// console.log(f1 instanceof Func); //true

// 检测某个对象是否具备这个属性【in】，再以及是否为私有属性【hasOwnProperty】
// console.log('say' in f1); //true
// console.log(f1.hasOwnProperty('say')); //true 
```

![](http://picbed.04091020.xyz/20200626115423.png)

**普通函数执行**  
1. 形成一个私有的上下文 EC(FUNC)，并且进栈执行（AO:name/age/n）  
2. 作用域链<EC(FUNC),EC(G)>/初始THIS:window/初始ARGUMENTS/形参赋值/变量提升  
3. 代码执行 window.name/age='xxx'/20  
4. 是否出栈释放  
var f = Func('xxx', 20);  1
console.log(f); //=>undefined  